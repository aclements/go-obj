// Copyright 2021 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// build.go builds all ELF test binaries and emits basic ELF test information.
//
// TODO: Separate building test binaries from producing the elfTest slice, since
// the test binaries depend on the available compilers and I may need to update
// elfTests based on binaries already built by another compiler.
package main

import (
	"bytes"
	"fmt"
	"go/format"
	"io"
	"io/ioutil"
	"log"
	"os"
	"os/exec"
	"regexp"
	"strconv"
	"strings"
)

type config struct {
	version string // Compiler version

	arch string // "I386", "AMD64"

	// typ is one of:
	//
	// - "static" for a statically linked executable
	//
	// - "dyn" for a dynamically linked executable
	//
	// - "pie" for a position-independent dynamically linked executable
	//
	// - "rel" for a relocatable object
	typ string

	strip bool // Produce a stripped binary

	compressDWARF bool
}

var testBuf bytes.Buffer

func main() {
	var c config
	fmt.Fprintf(&testBuf, `// Code generated by build.go. DO NOT EDIT.
	
package obj

import "github.com/aclements/go-obj/arch"

var elfTests = []*elfTest{
`)

	// Get the GCC version.
	c.version = "gcc" + gccVersion()

	for _, c.arch = range []string{"I386", "AMD64"} {
		for _, c.typ = range []string{"static", "dyn", "pie", "rel"} {
			c.build()

			// For dynamically linked executables, also produce a stripped
			// object. (We could do this for other executables, but it isn't
			// worth the space.)
			if c.typ == "dyn" {
				c.strip = true
				c.build()
				c.strip = false
			}
		}
	}

	// Build one with compressed DWARF.
	c.arch = "AMD64"
	c.typ = "rel"
	c.strip = false
	c.compressDWARF = true
	c.build()

	fmt.Fprintf(&testBuf, `}`)

	testSource, err := format.Source(testBuf.Bytes())
	if err != nil {
		log.Fatalf("formatting test source: %v", err)
	}
	if err := ioutil.WriteFile("../elftests_test.go", testSource, 0666); err != nil {
		log.Fatalf("writing tests: %v", err)
	}
}

func gccVersion() string {
	out := runOut("gcc", "--version")
	// Look for the last word of the first line.
	if i := strings.IndexByte(out, '\n'); i >= 0 {
		out = out[:i]
	}
	m := regexp.MustCompile(` [\d.]+$`).FindString(out)
	if m == "" {
		log.Fatalf("failed to find GCC version in `gcc --version`: %q", out)
	}
	return m[1:]
}

func (c config) build() {
	var extension string
	var flags []string

	label := c.version

	label += "-" + c.arch
	switch c.arch {
	case "I386":
		flags = append(flags, "-march=i386", "-m32")
	case "AMD64":
		flags = append(flags, "-march=x86-64", "-m64")
	default:
		log.Fatalf("bad arch %q", c.arch)
	}

	label += "-" + c.typ
	switch c.typ {
	case "static":
		flags = append(flags, "-static")
	case "dyn":
		flags = append(flags, "-no-pie")
	case "pie":
		flags = append(flags, "-pie")
	case "rel":
		flags = append(flags, "-c")
		extension = ".o"
	}

	// Always build a debug binary. There's little advantage to making this
	// yet another combination.
	flags = append(flags, "-g")

	if c.compressDWARF {
		label += "-gz"
		// Obj needs to be aware of zlib section-level compression, so we use
		// that type (it doesn't have to know about zlib-gnu)..
		flags = append(flags, "-gz=zlib")
	}

	outName := "hello-" + label + extension
	if c.strip {
		cmd := exec.Command("strip", "-o", outName+"-stripped", outName)
		if err := cmd.Run(); err != nil {
			log.Fatal(err)
		}
		c.printElfTest(outName + "-stripped")
		return
	}

	flags = append(flags, "-o", outName, "hello.c")

	cmd := exec.Command("gcc", flags...)
	cmd.Stderr = os.Stderr
	cmd.Stdout = os.Stdout
	if err := cmd.Run(); err != nil {
		log.Fatal(err)
	}

	c.printElfTest(outName)
}

func (c config) printElfTest(path string) {
	b := &testBuf
	fmt.Fprintf(b, `	{
		path: %q,
		arch: arch.%s,
`, path, c.arch)

	fmt.Fprintf(b, "sections: []Section{\n")
	sections := runOut("readelf", "--sections", "--wide", path)
	sectionRe := regexp.MustCompile(`(?m)^ *\[([ \d]+)\] (.*)`)
	for _, line := range strings.Split(sections, "\n") {
		m := sectionRe.FindStringSubmatch(line)
		if m == nil {
			continue
		}
		rawID := atoi(strings.TrimSpace(m[1]))
		if rawID == 0 {
			// obj leaves out the NULL section.
			continue
		}
		info := strings.Fields(m[2])
		name := info[0]
		addr := atoi("0x" + info[2])
		size := atoi("0x" + info[4])
		flags := info[6]
		if strings.Contains(flags, "C") {
			// Compressed section. Obj hides this. Let readelf decompress it.
			d := sectionData(path, name)
			size = len(d)
		}
		sectionFlags := []string{}
		if strings.Contains(flags, "A") && c.typ != "rel" {
			sectionFlags = append(sectionFlags, "sectionFlagMapped")
		}
		if !strings.Contains(flags, "W") {
			sectionFlags = append(sectionFlags, "sectionFlagReadOnly")
		}
		if info[1] == "NOBITS" {
			sectionFlags = append(sectionFlags, "sectionFlagZeroInitialized")
		}
		fmt.Fprintf(b, "{Name: %q, ID: %d, RawID: %d, Addr: %#x, Size: %#x, SectionFlags: SectionFlags{%s}},\n", name, rawID-1, rawID, addr, size, strings.Join(sectionFlags, "|"))
	}
	fmt.Fprintf(b, "},\n")

	syms := runOut("readelf", "--syms", "--wide", path)
	nSyms := len(regexp.MustCompile(`(?m)^ *\d+: `).FindAllString(syms, -1))
	// We don't count symbol 0 in each table.
	nSyms -= len(regexp.MustCompile(`(?m)^ *0: `).FindAllString(syms, -1))
	fmt.Fprintf(b, "nSyms: %d,\n", nSyms)

	// For some objects (with small text sizes), dump the whole text section.
	if (c.typ == "dyn" || c.typ == "rel") && !c.strip {
		fmt.Fprintf(b, "textData: parseHex(`%x`),\n", sectionData(path, ".text"))
	}

	// For compressed DWARF, dump the decompressed section.
	if c.compressDWARF {
		fmt.Fprintf(b, "debugInfoData: parseHex(`%x`),\n", sectionData(path, ".debug_info"))
	}

	fmt.Fprintf(b, "},\n")
}

func sectionData(path, section string) []byte {
	hex := runOut("readelf", "-x", section, "-z", path)
	var out []byte
	for _, line := range strings.Split(hex, "\n") {
		line = strings.TrimSpace(line)
		if !strings.HasPrefix(line, "0x") {
			continue
		}
		// Remove offset.
		line = line[strings.IndexByte(line, ' ')+1:]
		// Remove ASCII dump.
		line = line[:9*4]
		line = strings.TrimSpace(line)
		// Parse hex.
		for len(line) > 0 {
			if len(line) < 2 {
				panic("odd number of digits")
			}
			x, err := strconv.ParseUint(line[:2], 16, 8)
			if err != nil {
				panic(err)
			}
			out = append(out, byte(x))
			line = strings.TrimSpace(line[2:])
		}
	}
	return out
}

func dumpSection(b io.Writer, path, section string) {
	hex := runOut("readelf", "-x", section, "-z", path)
	fmt.Fprintf(b, "parseHex(`")
	for _, line := range strings.Split(hex, "\n") {
		line = strings.TrimSpace(line)
		if !strings.HasPrefix(line, "0x") {
			continue
		}
		// Remove offset.
		line = line[strings.IndexByte(line, ' ')+1:]
		// Remove ASCII dump.
		line = line[:9*4]
		line = strings.TrimSpace(line)
		fmt.Fprintf(b, "%s\n", line)
	}
	fmt.Fprintf(b, "`)")
}

func atoi(s string) int {
	v, err := strconv.ParseInt(s, 0, 0)
	if err != nil {
		panic(fmt.Sprintf("expected integer, got: %s", s))
	}
	return int(v)
}

func runOut(name string, args ...string) string {
	var buf strings.Builder
	cmd := exec.Command(name, args...)
	cmd.Stderr = os.Stderr
	cmd.Stdout = &buf
	if err := cmd.Run(); err != nil {
		log.Fatal(err)
	}
	return buf.String()
}
